
[{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/3sem/","section":"Tags","summary":"","title":"3Sem","type":"tags"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/devlog/","section":"Tags","summary":"","title":"Devlog","type":"tags"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/devlog/","section":"Devlogs","summary":"","title":"Devlogs","type":"devlog"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/","section":"Jesper Andersen - Blog \u0026 DevLog","summary":"","title":"Jesper Andersen - Blog \u0026 DevLog","type":"page"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/series/maintenance-log/","section":"Series","summary":"","title":"Maintenance Log","type":"series"},{"content":"Part 2 of the “Maintenance Log” series. So, welcome to this second entry of my Devlog. Without further ado, let\u0026rsquo;s continue into this week\u0026rsquo;s additions.\nRelations, DAOs and exception handling\r#\rThis week\u0026rsquo;s primary goal was to get the necessary relations between my entities up and running, begin to finalize the DAOs for each, and integrate interfaces both for simple CRUD and for specific queries across the board. After that, the project looked a bit like this:\nAfter that I began to add exception handling across my different CRUD operations. I made the design choice of adding my own custom DatabaseException class with some error types I can relate to common HTTP error codes, both to keep low coupling between layers and to have the correlation I need when I start to use APIException in the service layer to interpret DatabaseExceptions. For reference, I have thrown in my current custom exception, the error type enum and an example of how it\u0026rsquo;s used in the code:\npublic enum DatabaseErrorType { CONSTRAINT_VIOLATION , // 409 NOT_FOUND, // 404 CONNECTION_FAILURE, // 503 TRANSACTION_FAILURE, // 500 QUERY_FAILURE, // 500 UNKNOWN }\rpublic class DatabaseException extends RuntimeException { private final DatabaseErrorType errorType; public DatabaseException(String message, DatabaseErrorType errorType) { super(message); this.errorType = errorType; } public DatabaseException(String message, DatabaseErrorType errorType, Throwable cause) { super(message, cause); this.errorType = errorType; } public DatabaseErrorType getErrorType() { return errorType; } }\r@Override public User update(User u) { if (u == null || u.getUserId() == null) { throw new IllegalArgumentException(\u0026#34;User and user id are required\u0026#34;); } try (EntityManager em = emf.createEntityManager()) { em.getTransaction().begin(); try { User merged = em.merge(u); em.getTransaction().commit(); return merged; } catch (IllegalArgumentException e) { if (em.getTransaction().isActive()) { em.getTransaction().rollback(); } throw new DatabaseException(\u0026#34;User not found or invalid\u0026#34;, DatabaseErrorType.NOT_FOUND, e); } catch (PersistenceException e) { if (em.getTransaction().isActive()) { em.getTransaction().rollback(); } throw new DatabaseException(\u0026#34;Update User failed\u0026#34;, DatabaseErrorType.TRANSACTION_FAILURE, e); } catch (RuntimeException e) { if (em.getTransaction().isActive()) { em.getTransaction().rollback(); } throw new DatabaseException(\u0026#34;Update User failed\u0026#34;, DatabaseErrorType.UNKNOWN, e); } } }\rI think that includes the overhead of what happened this week. Next up is integration testing for all my DAOs.\nAnd finally a quick rundown of my current design decisions:\nMaintenance Log - Design Decisions (Updated)\r#\rUpdates Since Last Summary\r#\rCurrent state: DAO layer mostly complete will probably need to make more specific queries later when the need arises, integration tests planned next.\nMajor Design Changes\r#\r1. Asset Fetch Strategy Changed Back to LAZY\nPrevious: FetchType.EAGER on Asset.logs Current: FetchType.LAZY on Asset.logs Why changed back: EAGER would load all logs for all assets in list queries (performance concern) Solution: Use explicit queries when logs are needed, rely on lazy loading otherwise 2. Added Helper Method to Asset\nImplementation: Asset.addLog(MaintenanceLog log) helper method added Previous decision: No helper methods needed for stateless REST API Why changed: Provides convenient way to maintain bidirectional relationship consistency Usage: Optional convenience method, not required for persistence 3. Asset.logs Collection Initialized\nImplementation: private List\u0026lt;MaintenanceLog\u0026gt; logs = new ArrayList\u0026lt;\u0026gt;() Rationale: Prevents NullPointerException when using addLog() helper method 4. Added @OrderBy to Asset.logs\nImplementation: @OrderBy(\u0026quot;performedDate DESC\u0026quot;) Rationale: Logs always returned in chronological order (newest first) without manual sorting 5. Asset Entity Now Has Selective Mutability\nImplementation: Only active field has @Setter, other fields immutable after creation\nRationale:\nname and description shouldn\u0026rsquo;t change (audit trail) active status needs to change (deactivation workflow) ID never changes (automatically generated) 6. Comprehensive Exception Handling Added to DAO Layer\nImplementation: All DAO methods now wrap JPA exceptions in custom DatabaseException\nPattern:\nInput validation throws IllegalArgumentException (e.g., null checks) Read failures throw DatabaseException with QUERY_FAILURE error type Write failures throw DatabaseException with TRANSACTION_FAILURE error type \u0026ldquo;Not found\u0026rdquo; scenarios throw DatabaseException with NOT_FOUND error type Transaction safety: All write operations include proper rollback on any exception\nRationale:\nDecouples persistence layer from JPA implementation details Provides consistent exception interface for service layer Maps cleanly to HTTP status codes without exposing persistence concerns Distinguishes between different failure types for better error handling DAO Method Additions:\r#\rMaintenanceLogDAO:\ngetByPerformedUser(Integer userId) — cross-user log queries getLogsOnActiveAssets(int limit) — filtered + paginated queries UserDAO:\ngetActiveUsers(int limit) — paginated active users query AssetDAO:\nsetActive(Integer id, boolean active) — only allowed mutation getInactiveAssets() — query deactivated assets Structural Changes:\r#\rRemoved Task entity entirely Added TaskType enum Reorganized project structure into separate packages Added DAO interfaces layer Standardized exception handling across all DAOs Removed unnecessary new ArrayList\u0026lt;\u0026gt;() wrapping in DAO return statements 1. Immutability of Maintenance Logs\r#\rDecision: MaintenanceLog entries are never updated or deleted Implementation: MaintenanceLogDAO has NO update() method — throws UnsupportedOperationException Rationale: Data integrity and traceability (GDPR compliance, audit trail) Future consideration: Log corrections will reference previous entries (handled in service/GUI layer) 2. Soft Delete for Users\r#\rDecision: Users are deactivated, not deleted (active boolean field) Implementation: User.active field added No delete() method in UserDAO update() method used to set active = false Rationale: Preserve historical data — maintenance logs need to show who performed them, even after users leave 3. Immutability of Assets (with Exception)\r#\rDecision: Assets are immutable except for active status Implementation: Only active field has @Setter on entity name and description have no setters (immutable) AssetDAO.update() throws UnsupportedOperationException AssetDAO.setActive(Integer id, boolean active) allows only status changes Uses find() + setter pattern, not merge() Rationale: Asset details (name, description) should not change for audit trail Active status needs to change for operational/deactivation workflow Maintains data integrity while allowing necessary state management 4. Task System Redesigned as Enum\r#\rDecision: Removed Task entity, replaced with TaskType enum Implementation: public enum TaskType { PRODUCTION, MAINTENANCE, ERROR }\rPrevious design: Task entity with title and description Why changed: Task descriptions are unique per log (technician writes what they did) Only the category (title) is predefined Enum is simpler, type-safe, and matches actual use case Specific work details go in MaintenanceLog.comment field (now nullable = false) Rationale: Eliminates unnecessary entity and relationship, clearer domain model 5. Entity Relationships\r#\rMaintenanceLog relationships:\r#\r@ManyToOne to Asset (owning side, LAZY loading) @ManyToOne to User (owning side, LAZY loading) All relationships: nullable = false Changed: Removed @ManyToOne to Task (now uses TaskType enum) Asset relationship:\r#\r@OneToMany to MaintenanceLog (non-owning side) mappedBy = \u0026quot;asset\u0026quot; LAZY loading @OrderBy(\u0026quot;performedDate DESC\u0026quot;) — automatic chronological sorting Initialized to empty ArrayList\u0026lt;\u0026gt;() to prevent NullPointerException Optional helper method: addLog(MaintenanceLog log) for bidirectional consistency No setter on collection (relationship managed via MaintenanceLog creation or helper method) User relationship:\r#\rUnidirectional from MaintenanceLog to User User entity has no collection of logs Rationale: Logs are accessed via Asset or direct queries, not via User 6. Helper Methods on Entities\r#\rDecision: Asset.addLog(MaintenanceLog log) helper method added Previous decision: No helper methods needed Why changed: Provides convenient way to maintain bidirectional consistency if needed Usage: Optional — not required for persistence, can still manage via MaintenanceLog side only Implementation: Sets both sides of relationship (logs.add(log) and log.setAsset(this)) 7. DAO Layer Responsibilities and Architecture\r#\rDAOs are \u0026ldquo;dumb persistence\u0026rdquo; — no business logic\r#\rResponsibilities:\nCRUD operations Database queries via JPQL Exception wrapping (convert JPA exceptions to DatabaseException) Input validation (IllegalArgumentException for null/invalid inputs) Not responsible for:\nValidation (service layer) Business rules (service layer) HTTP concerns (controller layer) DAO Interfaces\r#\rImplementation: Separate interfaces (IDAO\u0026lt;T\u0026gt;, IUserDAO, etc.) for each DAO Rationale: Contract separation for testing Interface Segregation Principle Allows mocking in future tests 8. Exception Handling Strategy\r#\rCustom Exception Hierarchy\r#\rpublic class DatabaseException extends RuntimeException { private final DatabaseErrorType errorType; } public enum DatabaseErrorType { CONSTRAINT_VIOLATION, // 409 NOT_FOUND, // 404 CONNECTION_FAILURE, // 503 TRANSACTION_FAILURE, // 500 QUERY_FAILURE, // 500 UNKNOWN }\rException Rules\r#\r\u0026ldquo;Not found\u0026rdquo; throws exceptions (not returns null) Rationale: In this system, looking up by ID is expected to succeed (IDs from database) Failed lookup indicates something went wrong (deleted, corrupted) Service layer catches and converts to appropriate HTTP responses Read operations (SELECT) → DatabaseErrorType.QUERY_FAILURE Write operations (INSERT, UPDATE) → DatabaseErrorType.TRANSACTION_FAILURE Rationale: Clear distinction helps service layer understand failure type Input validation → IllegalArgumentException (not DatabaseException) Transaction Management\r#\rWrite operations: Explicit transaction with proper rollback on all exception types Read operations: No transaction needed Pattern: em.getTransaction().begin(); try { // operation em.getTransaction().commit(); } catch (PersistenceException e) { if (em.getTransaction().isActive()) { em.getTransaction().rollback(); } throw new DatabaseException(..., TRANSACTION_FAILURE, e); }\r9. Query Strategy\r#\rPrimary key lookups: Use em.find() (simpler, cached, returns null) Then check null and throw DatabaseException with NOT_FOUND Other queries: Use JPQL with TypedQuery and named parameters getSingleResult() handling: Catch NoResultException, rethrow as DatabaseException No unnecessary wrapping: Return query.getResultList() directly (removed new ArrayList\u0026lt;\u0026gt;() wrapper) 10. User Authentication Considerations\r#\rDecision: UserDAO.getByEmail() filters by active = true Rationale: Only active users can log in But: UserDAO.get(userId) returns all users (active or not) Rationale: Historical lookups need to show inactive users (who performed a log) 11. Field Protection\r#\rDecision: Manual @Setter annotations on individual fields Primary keys: NO setter (immutable after creation) Immutable entities (Asset): Only active field has setter Mutable entities (User): All fields except ID have setters Rationale: Prevents accidental ID modification and enforces immutability where needed 12. Email Uniqueness\r#\rDecision: Database-level constraint + service-layer validation Implementation: @Column(unique = true) on User.email Rationale: Defense in depth — database prevents duplicates, service layer provides better error messages 13. Merge vs. Find Pattern for Updates\r#\rDecision: Use find() + setter, not merge() with partial entities Implementation: Asset asset = em.find(Asset.class, id); asset.setActive(active); // commit auto-flushes\rRationale: Prevents accidentally clearing other fields More explicit about what\u0026rsquo;s being changed No need for defensive find-before-merge Clearer intent 14. Fetch Strategy\r#\rAsset.logs: LAZY loading with @OrderBy(\u0026quot;performedDate DESC\u0026quot;) Rationale: Prevents loading all logs when listing assets Ordering: Always returns logs newest-first without manual sorting Access: Explicit queries or navigation through relationship when needed All MaintenanceLog relationships: LAZY loading 15. GetAll() Methods\r#\rDecision: Included in all DAOs despite potential performance issues Rationale: School project requirement to demonstrate functionality Implementation: AssetDAO.getAll() only returns active assets Some methods have limit parameter for pagination (e.g., getActiveUsers(int limit)) Note: Should be paginated for production use Architecture Layers (Planned)\r#\r┌─────────────────────────────────┐ │ REST API (Javalin) │ ← HTTP status codes ├─────────────────────────────────┤ │ Service Layer │ ← Business rules, validation ├─────────────────────────────────┤ │ DAO Layer (Current) │ ← Database operations ├─────────────────────────────────┤ │ JPA/Hibernate │ ├─────────────────────────────────┤ │ PostgreSQL │ └─────────────────────────────────┘\r","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/devlog/maintenancelog-secondweek/","section":"Devlogs","summary":"Part 2 of the “Maintenance Log” series. So, welcome to this second entry of my Devlog. Without further ado, let’s continue into this week’s additions.\nRelations, DAOs and exception handling\r#\rThis week’s primary goal was to get the necessary relations between my entities up and running, begin to finalize the DAOs for each, and integrate interfaces both for simple CRUD and for specific queries across the board. After that, the project looked a bit like this:\n","title":"Maintenance Log - Second Week","type":"devlog"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/maintenancelog/","section":"Tags","summary":"","title":"MaintenanceLog","type":"tags"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/project/","section":"Tags","summary":"","title":"Project","type":"tags"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"13 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"6 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"Alrighty, let’s try to actually get a real “first” blog post going for this site.\nWhat I use AI for\r#\rFor today’s topic I wanted to talk a bit about my personal use of AI, briefly share my opinion on the doomsday talk about it taking our jobs, and explain how I use it day to day as a new programmer in a field where everything apparently is changing just as I get into it.\nWhen I’m perusing Reddit and various other online forums, or just hearing non‑developers talk, it sometimes seems like in a year none of us will be writing code. We’ll just prompt into Claude, Code, Codex, or whatever setup we’ve got going with multiple agents that check, triple‑check, and criticize each other’s output, and the human is just this “tech lead” with no real coding experience who simply trusts that whatever comes out will be flawless. The biggest question then becomes: how much can we charge for this “service” we just provided?\nWhy I’m not panicking about AI\r#\rI may be naive, but even with my limited time in software development I think that’s a bit of an overreaction — a feather that turned into ten chickens, so to speak (a very small thing blown way out of proportion). In reality, it’s probably more a question of how each individual uses the tools they’re given to increase their own productivity.\nWe may of course end up in a situation where we’re all the tech leads of our own little teams of AI agents, but I still believe that to use a tool well, you need to know both its use cases and its weaknesses, and use it as intended. It’s the good old analogy of using a hammer for every job when sometimes you need a screwdriver instead.\nUsing AI as a student\r#\rAfter that little rant, let’s get into how I’ve decided to use it for the moment. As a student I feel that it’s easy to just let Claude or ChatGPT take the wheel, and if you don’t question what it outputs or actually give it some constraints when you use it, it’s easy to end up in a situation where you just copy‑paste whatever it provides and don’t necessarily understand the solution it gives for assignments or what to question in its output.\nI’ve seen this just by watching now‑former fellow students who quickly gave into the temptation of quick solutions and ended up not getting the basic understanding needed to actually code something by themselves, instead of just relying blindly on an agent’s output. And I understand that it’s an easy temptation, especially if you don’t turn off things like:\nauto‑completion AI assistants integrated directly in your IDE of choice Why I mainly use Claude\r#\rI mainly use Claude for coding. Why? Because some people smarter than me said I should try it, and I actually like it for all my coding questions and mainly as a sparring partner for how I should structure a project.\nI started by setting up some personal references in my Claude settings on the web version (the one I use the most, just using it as a sparring partner), restricting it so it doesn’t give me direct answers right out of the gate, making me understand things using the Socratic learning method, and just treating me as a student at all times. This, however, turned tedious at points when you sometimes just need a question answered (like “what is the syntax for this thing specifically?” etc.).\nDaniel’s Claude setup\r#\rAfter actually discussing how we should use it with one of my good friends and study buddy, he sat down and made a whole set of instructions for Claude to use. I will paste it at the bottom of this blog post for you to peruse and try out yourself if you want to.\nI’ll just again, before I continue, give all credit to my friend Daniel who actually wrote this out. The only credit I will take for this is that I told him it existed and how I used it myself.\nSo as you can see, I have a lot of info on how we currently operate, and the plan is to update it with new technologies as we go and try to give ourselves the best opportunity to make progress, while still being the ones behind the wheel in this metaphorical car.\nExample: maintenance log project\r#\rI’ve actually used it for the little maintenance log project I’m working on, again as a way to have a sparring partner, using the associated tutor mode. Here are some quick examples of how it worked:\nMy first prompt was simply the README of my project and the entities I have defined (all can be found in my first devlog update), and the input I got out was then as follows:\nAs you can see, it then wants me to explain my choices and question those if needed. This is not for my basic coding understanding, but to train my brain to think about these things, and I need a sounding board for that — sometimes a rubber duck just isn’t good enough.\nAnyway, I think this is where I’ll cut it for now. I just had some quick thoughts I wanted to put down on the (preferably) digital paper.\nVERSION 2.0 DATAMATIKER STUDY ASSISTANT You are a programming assistant for practical software development tasks. Interaction is controlled via explicit behaviour modes. If no behaviour is specified, default behaviour applies. CONTEXT (INFORMATION ONLY) Education: - Datamatiker, 3rd semester Tech Stack: - Java (JDK 17) - JavaScript (ES6) - React - HTML - CSS - PostgreSQL - Maven - JUnit 5 - Java Persistence API - Javalin - IntelliJ IDEA - Git via Github - Hibernate Code Quality Focus: - Conventions, SOLID principles, loose coupling, high cohesion - Database normalization, security (GDPR, SQL injection) - Maintainability over cleverness - Appropriate error handling Preferences: - Clean, maintainable code - Convention over configuration - No overengineering - Danish / EU context when relevant This section provides background only. Do not infer behaviour from this section. BEHAVIOUR MODEL Conversation-level behaviours use the \u0026#39;@\u0026#39; prefix and remain active until replaced. Prompt-specific behaviours use the \u0026#39;#\u0026#39; prefix and supplement the active @ mode for one response only. Prompt-specific behaviours do not change the active conversation behaviour. @vanilla overrides all behaviours and constraints. If no @ mode has been explicitly set, @quick is active by default PRECEDENCE RULES 0. If no @ mode has been set, @quick is active by default 1. @vanilla overrides everything 2. #help and #listcurrent are meta-commands that display system info 3. # (prompt-specific) supplements @ (conversation-level) for one response 4. If # and @ behaviors conflict, # takes precedence for that response only 5. Only one @ behaviour can be active at a time (if multiple specified, the LAST one takes effect) 6. Multiple # behaviours can be combined (e.g., #solution #tdd) CONVERSATION-LEVEL BEHAVIOURS @quick (DEFAULT) - Default conversation behaviour - Provide a direct answer or conclusion - Include a short, concrete justification (1–2 sentences) - No concept explanations - No teaching - No step-by-step reasoning @tutor - Act as mentor, not solution provider - Give feedback, hints, and guidance instead of complete answers - Ask leading questions to help discover solutions - Encourage step-by-step problem-solving - Point out mistakes and explain WHY they\u0026#39;re problematic - Include TDD by default (use #notdd to skip) @teach - Teaching mode focused on preparing students for assessments - Explain concepts thoroughly with clear reasoning - Use precise terminology and proper explanations - Break down complex topics into digestible parts - Emphasize WHY things work, not just HOW - Provide context and real-world connections - Build understanding progressively - Avoid unnecessary repetition @vanilla Ignore all custom behaviours, preferences, and constraints defined in this settings prompt. Respond using default Claude behaviour as if no custom instructions were provided. Remains active until another @ mode is set. PROMPT-SPECIFIC BEHAVIOURS #solution Provide a complete solution. Include full code if relevant. Minimal justification only. #explain Explain concepts or decisions in depth. Brevity is not required. #review Code review only. Evaluate: conventions, SOLID principles, coupling/cohesion, security, maintainability. Be direct about problems. No teaching. No guidance. #debug Identify likely causes. Suggest concrete fixes. Avoid theory unless necessary. #refactor Improve existing code only. No new features. Focus on structure and clarity. #pseudocode Describe logic and algorithms only. Avoid language-specific syntax. #tdd Test-driven development approach. Write tests first. Show red-green-refactor cycle. Explain what each test validates. #listcurrent Display the currently active behaviour settings at the start of the response. Output format must be exactly: Conversation mode: @[mode] Prompt modifiers: #[modifier1], #[modifier2], ... If no conversation mode has been explicitly set, show: Conversation mode: @quick (DEFAULT) If no prompt modifiers except #listcurrent, show: Prompt modifiers: none Behaviour rules: - If #listcurrent is used alone, output ONLY the status and end the response. - If #listcurrent is combined with other @ or # commands, display the status first, then continue with the response using the active behaviours. - Do NOT explain or describe the behaviours themselves. #help Output the HELP TEXT section verbatim inside a plain text code block. Do not modify, summarize, or reformat the content. Then end the response with no additional text. HELP TEXT ================================================================================ DATAMATIKER STUDY ASSISTANT — v2.0 Purpose: Structured AI assistance for software development education Target group: Datamatiker students Institution: Erhvervsakademi København Author: Daniel Hangaard Last updated: January 2025 ================================================================================ HOW THIS WORKS This prompt customizes Claude\u0026#39;s behavior using commands: - @ commands set conversation mode (stays active until changed) - # commands modify single responses (one-time use) - You can combine them: \u0026#34;@tutor #pseudocode\u0026#34; ================================================================================ CONVERSATION MODES (@) ================================================================================ @quick (DEFAULT) - Direct answers, brief justification @tutor - Mentoring mode, guiding questions @teach - Exam-style, precise terminology @vanilla - Default Claude, ignores all settings (until new @ mode set) ================================================================================ PROMPT MODIFIERS (#) ================================================================================ #solution - Complete code, minimal explanation #explain - Detailed explanations #review - Code review (quality, conventions, security) #debug - Identify bugs, suggest fixes #refactor - Improve structure only #pseudocode - Algorithm/logic, no syntax #listcurrent - Show active modes #help - Show this help ================================================================================ USAGE ================================================================================ Set mode: \u0026#34;@tutor\u0026#34; (Only one active at a time) Add modifier: \u0026#34;#solution\u0026#34; Combine: \u0026#34;@quick #explain #tdd\u0026#34; (quick mode BUT in-depth explanation with TDD) Use: @quick for most questions Use: @tutor when learning new topics Use: @teach when preparing for assessments Use: #listcurrent if behavior seems wrong Use: @vanilla if custom settings cause issues ================================================================================ EXAMPLES ================================================================================ \u0026#34;@quick How do I connect to PostgreSQL?\u0026#34; → Direct answer with brief justification, no teaching \u0026#34;@tutor How do I connect to PostgreSQL?\u0026#34; → Guided response using leading questions and hints, no direct solution \u0026#34;@teach What is dependency injection?\u0026#34; → Structured, thorough explanation using correct terminology and examples \u0026#34;#solution #tdd Create a login validator\u0026#34; → Complete solution presented using a test-driven development approach \u0026#34;@quick #review\u0026#34; + [code] → Concise code review highlighting key issues without teaching \u0026#34;@teach #review\u0026#34; + [code] → Structured explanation of issues using correct terminology \u0026#34;#listcurrent\u0026#34; → Displays the currently active conversation mode and prompt modifiers ================================================================================\r","date":"6 February 2026","externalUrl":null,"permalink":"/Portfolio/posts/06-07-2026-ai-my-use/","section":"Posts","summary":"Alrighty, let’s try to actually get a real “first” blog post going for this site.\nWhat I use AI for\r#\rFor today’s topic I wanted to talk a bit about my personal use of AI, briefly share my opinion on the doomsday talk about it taking our jobs, and explain how I use it day to day as a new programmer in a field where everything apparently is changing just as I get into it.\n","title":"AI and how I use it","type":"posts"},{"content":"","date":"6 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"So, first of all, welcome to this first week post of the development of my little maintenance log. Just for posterity, let\u0026rsquo;s start with what is in my README for the project, since that actually breaks down what it is:\n#\rMaintenance Log Backend\r#\rThis project is a backend API for managing maintenance history of assets such as machines, vehicles, or equipment.\nThe system focuses on traceability and data integrity by storing maintenance activities as immutable logs. Each log represents a concrete maintenance action performed on an asset at a specific point in time.\nThe application is developed incrementally as a school project on the third semester at EK. Lyngby, where new backend technologies and architectural concepts are gradually introduced and integrated into the same system.\nCore concepts\r#\rAssets that require maintenance Maintenance logs representing performed work Users with different roles (e.g. technician, manager, admin) Historical data that should not be modified or deleted Initial scope\r#\rThe initial version of the system focuses on a simple domain model with assets and maintenance logs, exposing basic CRUD functionality through a REST API.\nAuthentication, authorization, validation, testing, and deployment concerns will be added progressively as the project evolves.\nGoal\r#\rThe goal of this project is to build a production-ready backend system that demonstrates clean structure, realistic business rules, and continuous technical progression.\nSo after that piece of business pitch, lets go into what actually happened this week:\nThe Project \u0026amp; Hibernate\r#\rThis week\u0026rsquo;s focus was to get Hibernate integrated into the project and understand how the different annotations work and what they do. I started by defining which entities my project should have and how my structure should look going forward. I started by sketching a quick class diagram in PlantUML.\nAnd finally a quick rundown of my current design decisions:\nand finally a quick rundown of my current design decisions:\nMaintenance Log - Design Decisions\r#\r1. Immutability of Maintenance Logs\r#\rDecision: MaintenanceLog entries are never updated or deleted Implementation: MaintenanceLogDAO has NO update() or delete() methods Rationale: Data integrity and traceability (GDPR compliance, audit trail) Future consideration: Log corrections will reference previous entries (handled in service/GUI layer) 2. Soft Delete for Users\r#\rDecision: Users are deactivated, not deleted (active boolean field) Implementation: User.active field added No delete() method in UserDAO update() method used to set active = false Rationale: Preserve historical data — maintenance logs need to show who performed them, even after users leave 3. Entity Relationships\r#\rMaintenanceLog relationships:\r#\r@ManyToOne to Asset (owning side) @ManyToOne to Task (owning side) @ManyToOne to User (owning side) All relationships: LAZY loading, nullable = false Asset relationship:\r#\r@OneToMany to MaintenanceLog (non-owning side) mappedBy = \u0026quot;asset\u0026quot; LAZY loading No setter (only managed via MaintenanceLog creation) 4. No Helper Methods on Entities\r#\rDecision: No addLog() helper method in Asset Rationale: Stateless REST API — entities reloaded fresh each request, so in-memory bidirectional sync not needed Implementation: All relationships managed via builder pattern on owning side (MaintenanceLog) 5. DAO Layer Responsibilities\r#\rDAOs are \u0026ldquo;dumb persistence\u0026rdquo; — no business logic\r#\rResponsibilities:\nCRUD operations Database queries Return null for not-found (consistent with em.find()) Not responsible for:\nValidation (service layer) Business rules (service layer) HTTP concerns (controller layer) 6. Transaction Management\r#\rDecision: Transactions only on write operations Read operations (SELECT queries): NO transaction Write operations (INSERT, UPDATE): Transaction required 7. Query Strategy\r#\rPrimary key lookups: Use em.find() (simpler, cached) Other queries: Use JPQL with named parameters Consistency: Methods return null when not found (not exceptions) Exception: getByEmail() catches NoResultException and returns null 8. User Authentication Considerations\r#\rDecision: UserDAO.getByEmail() filters by active = true Rationale: Only active users can log in But: UserDAO.get(userId) returns all users (active or not) Rationale: Historical lookups need to show inactive users (who performed a log) 9. Field Protection\r#\rDecision: Manual @Setter annotations on individual fields Primary keys: NO setter (immutable after creation) Other fields: Setters allowed for updates Rationale: Prevents accidental ID modification 10. Email Uniqueness\r#\rDecision: Database-level constraint + service-layer validation Implementation: @Column(unique = true) on User.email Rationale: Defense in depth — database prevents duplicates, service layer provides better error messages Portfolio Site\r#\rFinally, to end this \u0026ldquo;little\u0026rdquo; entry for the week, I think actually talking a little about this Hugo/Blowfish template thing is in its place. It has been a fun little side thing to get up and running, and I look forward to tinkering with the different settings and finding out how everything actually operates as I go further along. I\u0026rsquo;m doubtful if I will use this for other things than a dev log at the moment, but maybe I should start my new life as a bread blogger as well. I just think there is too much sourdough in the world already, and I think I only get a short runway on throwing up pictures of my normal yeast bread.\n","date":"6 February 2026","externalUrl":null,"permalink":"/Portfolio/devlog/maintenancelog-firstweek/","section":"Devlogs","summary":"So, first of all, welcome to this first week post of the development of my little maintenance log. Just for posterity, let’s start with what is in my README for the project, since that actually breaks down what it is:\n#\rMaintenance Log Backend\r#\rThis project is a backend API for managing maintenance history of assets such as machines, vehicles, or equipment.\n","title":"Maintenance Log - First Week","type":"devlog"},{"content":"","date":"6 February 2026","externalUrl":null,"permalink":"/Portfolio/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"First Blog, alot of testing going on with this template\u0026hellip; nothing is set in stone for how it looks, but lets see where we end up when were done.\n","date":"5 February 2026","externalUrl":null,"permalink":"/Portfolio/posts/0502-2026/","section":"Posts","summary":"First Blog, alot of testing going on with this template… nothing is set in stone for how it looks, but lets see where we end up when were done.\n","title":"First Blog","type":"posts"},{"content":"","date":"5 February 2026","externalUrl":null,"permalink":"/Portfolio/tags/firstpost/","section":"Tags","summary":"","title":"FirstPost","type":"tags"},{"content":"If you’ve somehow found your way here: welcome!\nMy name is Jesper Andersen. At the time of writing this (2026), I’m in my early thirties and currently working on my AP degree in Computer Science at EK – Lyngby in Denmark.\nBefore this, I spent 14 years in construction working as a journeyman painter.\nWhen I’m not busy being a student, I spend my time being a father (to two lovely daughters), a husband, a recreational bodybuilder, an enjoyer of video games, and an amateur Warhammer painter. I also own two cats: one loves me, and the other merely accepts my presence in the household.\n","externalUrl":null,"permalink":"/Portfolio/aboutme/","section":"Jesper Andersen - Blog \u0026 DevLog","summary":"If you’ve somehow found your way here: welcome!\nMy name is Jesper Andersen. At the time of writing this (2026), I’m in my early thirties and currently working on my AP degree in Computer Science at EK – Lyngby in Denmark.\nBefore this, I spent 14 years in construction working as a journeyman painter.\n","title":"About me","type":"page"},{"content":"","externalUrl":null,"permalink":"/Portfolio/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/Portfolio/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]